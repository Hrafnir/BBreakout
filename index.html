<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>BBreakout v1.5 - Enhanced HTML Arkanoid</title>
<style>
    /* CSS KODE (samme som før, justert for 800x600) */
    body {
        background: #222;
        margin: 0;
        padding: 20px 0;
        display: flex;
        justify-content: center;
        min-height: 100vh;
        font-family: Arial, sans-serif;
        color: #fff;
        overflow: hidden;
    }
    #gameContainer {
        position: relative;
        width: 800px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    canvas {
        display: block;
        border: 1px solid #555;
    }
    .hidden {
        display: none !important;
    }
    #startScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 800px;
        height: 600px;
        background-color: #1a1a1a;
        /* ====> HUSK RIKTIG STI TIL BILDET DITT HER! <==== */
        background-image: url('image/BBreakout.png');
        background-size: cover;
        background-position: center;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10;
        border: 1px solid #555;
        box-sizing: border-box;
    }
     #startScreenContent {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 300px;
        background: rgba(0,0,0,0.5);
        padding: 20px;
        border-radius: 10px;
    }
    #startButton {
        padding: 15px 30px;
        font-size: 24px;
        cursor: pointer;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        box-shadow: 0 4px #999;
        transition: background-color 0.2s, box-shadow 0.2s, transform 0.2s;
    }
    #startButton:hover { background-color: #45a049; }
     #startButton:active { background-color: #3e8e41; box-shadow: 0 2px #666; transform: translateY(2px); }
    #versionText {
        position: absolute;
        bottom: 15px;
        right: 15px;
        font-size: 14px;
        color: rgba(255, 255, 255, 0.7);
    }
    #uiContainer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        padding: 8px 15px;
        background: rgba(0,0,0,0.6);
        box-sizing: border-box;
        border-bottom-left-radius: 5px;
        border-bottom-right-radius: 5px;
        margin-top: -1px;
        height: 50px;
    }
    #gameInfo { display: flex; gap: 20px; }
     #audioControls { display: flex; align-items: center; gap: 10px; }
     #audioControls label { font-size: 14px; margin-right: -5px; }
    #volumeSlider { width: 100px; cursor: pointer; accent-color: #0095DD; }
    #muteButton { padding: 5px 10px; font-size: 12px; cursor: pointer; background-color: #0077AA; color: white; border: none; border-radius: 3px; min-width: 60px; text-align: center; }
     #muteButton:hover { background-color: #005588; }
</style>
</head>
<body>

<div id="gameContainer">
    <div id="startScreen">
         <div id="startScreenContent">
            <button id="startButton">Start Spillet</button>
         </div>
        <div id="versionText">Versjon 1.5</div> </div>

    <canvas id="gameCanvas" width="800" height="600" class="hidden"></canvas>

    <div id="uiContainer" class="hidden">
        <div id="gameInfo">
            <span id="score">Poeng: 0</span>
            <span id="lives">Liv: 3</span>
            <span id="level">Nivå: 1</span>
        </div>
        <div id="audioControls">
             <label for="volumeSlider">Volum:</label>
            <input type="range" id="volumeSlider" min="0" max="100" value="20">
            <button id="muteButton">Mute</button>
        </div>
    </div>
</div>

<audio id="backgroundMusic" loop preload="auto">
    <source src="audio/BBreakout.mp3" type="audio/mpeg"> Nettleseren din støtter ikke audio-elementet.
</audio>
<audio id="hitSound" preload="auto">
    <source src="audio/hit.wav" type="audio/wav"> Nettleseren din støtter ikke audio-elementet.
</audio>
<audio id="paddleSound" preload="auto">
    <source src="audio/paddle.wav" type="audio/wav"> Nettleseren din støtter ikke audio-elementet.
</audio>


<script>
    // --- DOM Element References ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const livesElement = document.getElementById('lives');
    const levelElement = document.getElementById('level');
    const startScreen = document.getElementById('startScreen');
    const startButton = document.getElementById('startButton');
    const uiContainer = document.getElementById('uiContainer');
    const volumeSlider = document.getElementById('volumeSlider');
    const muteButton = document.getElementById('muteButton');
    const versionText = document.getElementById('versionText');

    // Audio Elements
    const backgroundMusic = document.getElementById('backgroundMusic');
    const hitSound = document.getElementById('hitSound');
    const paddleSound = document.getElementById('paddleSound');
    const allSounds = [backgroundMusic, hitSound, paddleSound]; // Group for easier control

    // --- Spillkonstanter og Variabler ---
    const VERSION = "1.5";
    const CANVAS_WIDTH = canvas.width;
    const CANVAS_HEIGHT = canvas.height;
    const PADDLE_HEIGHT = 15;
    const PADDLE_BASE_WIDTH = 120;
    const PADDLE_SPEED = 10;
    const BALL_RADIUS = 10;
    const INITIAL_BALL_SPEED = 4.5;
    const BRICK_WIDTH = 65;
    const BRICK_HEIGHT = 20;
    const BRICK_PADDING = 8;
    const BRICK_OFFSET_TOP = 50;
    const PARTICLE_LIFESPAN = 30;
    const POWERUP_CHANCE = 0.15;
    const POWERUP_SPEED = 2.0;
    const POWERUP_SIZE = 18;
    const INITIAL_VOLUME = 0.2;

    // Farger
    const BRICK_HEALTH_COLORS = { 4: "#FF1493", 3: "#8333FF", 2: "#FF8D33", 1: "#FFC300", };
    const BRICK_DEFAULT_COLOR = "#DAF7A6";
    const PADDLE_COLOR = { main: '#0095DD', accent: '#00CFFF' };
    const BALL_COLOR = { main: '#FFFFFF', accent: '#DDDDDD' };
    const BACKGROUND_GRADIENT = ['#111', '#333', '#111'];
    const PARTICLE_COLORS = ["#FFA07A", "#FF7F50", "#FF6347", "#FF4500"];
    const POWERUP_COLORS = { 'LARGER_PADDLE': '#33FF57', 'MULTI_BALL': '#FFC300', 'SLOW_BALL': '#33D4FF', 'EXTRA_LIFE': '#FF5733' };

    // Nivådata (10 kolonner)
    const LEVELS = [
        // Nivå 1
        [ [[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1]], [[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1]], [[0,0],[0,0],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[0,0],[0,0]], [[0,0],[0,0],[0,0],[1,1],[1,1],[1,1],[1,1],[0,0],[0,0],[0,0]] ],
        // Nivå 2
        [ [[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2]], [[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1]], [[0,0],[1,1],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[1,1],[0,0]], [[0,0],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[0,0]], [[0,0],[0,0],[0,0],[1,1],[1,1],[1,1],[1,1],[0,0],[0,0],[0,0]] ],
         // Nivå 3
        [ [[1,1],[2,2],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[2,2],[1,1]], [[1,1],[2,2],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[2,2],[1,1]], [[1,1],[2,2],[0,0],[2,2],[2,2],[2,2],[2,2],[0,0],[2,2],[1,1]], [[0,0],[1,1],[2,2],[1,1],[1,1],[1,1],[1,1],[2,2],[1,1],[0,0]], [[0,0],[0,0],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[0,0],[0,0]] ],
        // Nivå 4 - Tøffere
        [ [[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3],[3,3]], [[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2],[2,2]], [[3,3],[0,0],[3,3],[0,0],[3,3],[0,0],[3,3],[0,0],[3,3],[0,0]], [[2,2],[0,0],[2,2],[0,0],[2,2],[0,0],[2,2],[0,0],[2,2],[0,0]], [[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1],[1,1]] ],
    ];


    // Spillstatus
    let paddleWidth = PADDLE_BASE_WIDTH;
    let paddleX = (CANVAS_WIDTH - paddleWidth) / 2;
    let paddleLastX = paddleX;
    let paddleVelX = 0;
    let rightPressed = false;
    let leftPressed = false;
    let balls = [];
    let bricks = [];
    let particles = [];
    let powerups = [];
    let score = 0;
    let lives = 3;
    let currentLevel = 1;
    let gameRunning = false; // Hovedkontroll for om spillet kjører
    let gamePaused = false; // For overganger (ikke lenger brukt i loop-sjekk)
    let bricksRemaining = 0;
    let activePowerups = { largerPaddle: null, slowBall: null };
    let animationFrameId = null; // Holder ID for requestAnimationFrame
    let isMuted = false;
    let lastVolume = INITIAL_VOLUME;

    const PowerupType = { LARGER_PADDLE: 'LARGER_PADDLE', MULTI_BALL: 'MULTI_BALL', SLOW_BALL: 'SLOW_BALL', EXTRA_LIFE: 'EXTRA_LIFE' };

    // --- Lydkontroll ---
    function playSound(soundElement) {
        if (!soundElement || typeof soundElement.play !== 'function') {
             console.warn("playSound: Invalid sound element provided or missing play method.", soundElement);
             return; // Ikke prøv å spille ugyldig element
        }
        if (isMuted) return; // Ikke spill hvis mutet

        try {
            soundElement.currentTime = 0; // Spol tilbake
             // play() returnerer et Promise
            const playPromise = soundElement.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    // Vanlig feil: brukerinteraksjon kreves. Logg KUN hvis det er en annen feil.
                    if (error.name !== 'NotAllowedError' && error.name !== 'AbortError') {
                       console.error(`Audio play failed for ${soundElement.id || 'unknown element'}:`, error);
                    } else {
                         // console.log("Audio playback ignored/prevented (likely needs user interaction or was interrupted).");
                    }
                });
            }
        } catch (e) {
            console.error(`Error trying to play sound ${soundElement.id || 'unknown element'}:`, e);
        }
    }

    function setGlobalVolume(volume) {
        lastVolume = volume;
        console.log(`Setting global volume to: ${volume.toFixed(2)}`); // DEBUG
        allSounds.forEach(sound => {
            if (sound) {
                 try { sound.volume = volume; } catch (e) { console.error("Error setting volume for element:", sound, e); }
             }
        });
    }

    function toggleMute() {
        isMuted = !isMuted;
        if (isMuted) {
             console.log("Muting all sounds."); // DEBUG
             allSounds.forEach(sound => { if (sound) sound.volume = 0; });
             muteButton.textContent = "Unmute";
        } else {
             console.log("Unmuting all sounds, setting volume to:", lastVolume); // DEBUG
             setGlobalVolume(lastVolume); // Gjenopprett volum
             volumeSlider.value = lastVolume * 100;
             muteButton.textContent = "Mute";
        }
    }

    function setupAudioControls() {
        console.log("Setting up audio controls...");
        try {
            // Initial volume setup
            setGlobalVolume(INITIAL_VOLUME);
            volumeSlider.value = INITIAL_VOLUME * 100;
            lastVolume = INITIAL_VOLUME;

            isMuted = false;
            muteButton.textContent = "Mute";

            volumeSlider.oninput = null; // Fjern gamle listeners
            muteButton.onclick = null;

            volumeSlider.oninput = (e) => {
                const newVolume = e.target.value / 100;
                setGlobalVolume(newVolume); // Setter lastVolume og volum på alle elementer
                if (newVolume > 0 && isMuted) { // Hvis vi var mutet, unmute
                    isMuted = false;
                    muteButton.textContent = "Mute";
                    console.log("Unmuted via volume slider.");
                } else if (newVolume === 0 && !isMuted) { // Hvis volum blir 0, mute
                     isMuted = true;
                     muteButton.textContent = "Unmute";
                     console.log("Muted via volume slider to 0.");
                }
            };

            muteButton.onclick = toggleMute;
             console.log("Audio controls setup complete."); // DEBUG

        } catch (error) {
             console.error("Error setting up audio controls:", error);
        }
    }

    // --- Start Spillet Funksjon ---
    function startGame() {
        console.log("--- startGame called ---");

        // 1. Update UI visibility
        startScreen.classList.add('hidden');
        canvas.classList.remove('hidden');
        uiContainer.classList.remove('hidden');
        console.log("UI elements visibility updated.");

        // 2. Setup Audio
        console.log("Setting up audio controls...");
        setupAudioControls();
        console.log("Attempting to play background music...");
        playSound(backgroundMusic);

        // 3. Reset Game State
        console.log("Resetting game state...");
        score = 0; lives = 3; currentLevel = 1;
        gamePaused = false; // Sikre at ikke pauset
        gameRunning = true; // Sett til å kjøre

        // 4. Initialize Level
        console.log("Initializing level 1...");
        initializeLevel(currentLevel); // Ball, bricks etc.

        // 5. Start Game Loop
        console.log("Checking animationFrameId before starting loop:", animationFrameId);
        if (!animationFrameId) {
            console.log("Starting game loop...");
            gameLoop();
        } else {
            console.warn("startGame: gameLoop seems to be already running? ID:", animationFrameId);
            cancelAnimationFrame(animationFrameId); // Stopp den gamle
            animationFrameId = null;
            console.log("Restarting game loop forcefully.");
            gameLoop(); // Start på nytt
        }
        console.log("--- startGame finished ---");
    }
    startButton.addEventListener('click', startGame);
    versionText.textContent = `Versjon ${VERSION}`;


    // --- Initialisering ---
    function initializeLevel(level) {
        console.log("--- Initializing level:", level, "---");
        paddleWidth = PADDLE_BASE_WIDTH;
        paddleX = (CANVAS_WIDTH - paddleWidth) / 2;
        paddleLastX = paddleX; paddleVelX = 0;
        balls = [];

        const initialAngle = (Math.random() * 60 + 60) * (Math.PI / 180);
        createBall(
            CANVAS_WIDTH / 2,
            CANVAS_HEIGHT - PADDLE_HEIGHT - BALL_RADIUS - 50,
            Math.cos(initialAngle) * INITIAL_BALL_SPEED,
           -Math.sin(initialAngle) * INITIAL_BALL_SPEED
        );

        initializeBricks();
        powerups = []; particles = [];
        if (activePowerups.largerPaddle) clearTimeout(activePowerups.largerPaddle);
        if (activePowerups.slowBall) clearTimeout(activePowerups.slowBall);
        activePowerups = { largerPaddle: null, slowBall: null };

        updateUI(); // Oppdater poeng/liv/nivå visning
        console.log("--- Level", level, "initialization complete ---");
    }


    // --- Spillogikk Funksjoner ---
     function createBall(x, y, dx, dy) { /* ... (samme som før) ... */ }

     function initializeBricks() {
         bricks = [];
         bricksRemaining = 0;
         const levelIndex = currentLevel - 1;

         if (levelIndex >= LEVELS.length) { victory(); return; }

         const levelData = LEVELS[levelIndex];
         const numRows = levelData.length;
         let numCols = 0;
         if (numRows > 0 && Array.isArray(levelData[0])) { // Ekstra sjekk
              numCols = levelData[0].length;
         } else {
              console.error("Invalid level data format for level:", currentLevel);
              return; // Kan ikke bygge brett
         }

         const totalBrickGridWidth = numCols * BRICK_WIDTH + (numCols - 1) * BRICK_PADDING;
         const calculatedOffsetLeft = (CANVAS_WIDTH - totalBrickGridWidth) / 2;
         console.log(`Level ${currentLevel}: ${numCols} columns, OffsetLeft: ${calculatedOffsetLeft.toFixed(1)}`);

         for (let r = 0; r < numRows; r++) {
              if (!Array.isArray(levelData[r]) || levelData[r].length !== numCols) {
                  console.warn(`Level ${currentLevel}, row ${r} has invalid format or length.`);
                  continue;
              }
             for (let c = 0; c < numCols; c++) {
                 // Endret til å hente helse fra det første elementet i paret
                 const brickHealthData = levelData[r][c];
                 if (!Array.isArray(brickHealthData) || brickHealthData.length === 0) {
                      console.warn(`Invalid brick data at row ${r}, col ${c}`);
                      continue;
                 }
                 const brickHealth = brickHealthData[0]; // Hent helsen

                 if (brickHealth > 0) {
                     const brickX = (c * (BRICK_WIDTH + BRICK_PADDING)) + calculatedOffsetLeft;
                     const brickY = (r * (BRICK_HEIGHT + BRICK_PADDING)) + BRICK_OFFSET_TOP;
                     bricks.push({
                         x: brickX, y: brickY,
                         w: BRICK_WIDTH, h: BRICK_HEIGHT,
                         status: 1, initialHealth: brickHealth, health: brickHealth,
                         color: BRICK_HEALTH_COLORS[brickHealth] || BRICK_DEFAULT_COLOR
                     });
                     bricksRemaining++;
                 }
             }
         }
         console.log("Bricks initialized. Count:", bricksRemaining);
     }

    // --- Input Handlers (uendret) ---
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);
    document.addEventListener("mousemove", mouseMoveHandler, false);
    function keyDownHandler(e) { if(e.key == "Right" || e.key == "ArrowRight") rightPressed = true; else if(e.key == "Left" || e.key == "ArrowLeft") leftPressed = true; }
    function keyUpHandler(e) { if(e.key == "Right" || e.key == "ArrowRight") rightPressed = false; else if(e.key == "Left" || e.key == "ArrowLeft") leftPressed = false; }
    function mouseMoveHandler(e) { const rect = canvas.getBoundingClientRect(); const root = document.documentElement; let relativeX = e.clientX - rect.left - root.scrollLeft; if (relativeX > paddleWidth / 2 && relativeX < CANVAS_WIDTH - paddleWidth / 2) { paddleX = relativeX - paddleWidth / 2; } else if (relativeX <= paddleWidth / 2) { paddleX = 0; } else { paddleX = CANVAS_WIDTH - paddleWidth; } }

    // --- Collision Detection ---
    function collisionDetection() {
        // Fjernet gamePaused sjekk her, styres av gameRunning i gameLoop
        let levelMightBeComplete = false;

        balls.forEach((ball, ballIndex) => {
            // Kollisjon med klosser
            for (let i = bricks.length - 1; i >= 0; i--) {
                let b = bricks[i];
                if (b.status == 1) {
                    if (ball.x + ball.radius > b.x && ball.x - ball.radius < b.x + b.w &&
                        ball.y + ball.radius > b.y && ball.y - ball.radius < b.y + b.h)
                    {
                        playSound(hitSound);
                        const overlapX = (ball.radius + b.w / 2) - Math.abs(ball.x - (b.x + b.w / 2));
                        const overlapY = (ball.radius + b.h / 2) - Math.abs(ball.y - (b.y + b.h / 2));

                        if (overlapX < overlapY) { ball.dx = -ball.dx; ball.x += (ball.x > b.x + b.w / 2 ? overlapX : -overlapX); }
                        else { ball.dy = -ball.dy; ball.y += (ball.y > b.y + b.h / 2 ? overlapY : -overlapY); }

                        b.health--; score += 5;

                        if (b.health <= 0) {
                            b.status = 0; score += 15 * b.initialHealth; bricksRemaining--;
                            createParticles(ball.x, ball.y, b.color);
                            if (Math.random() < POWERUP_CHANCE) createPowerup(b.x + b.w / 2, b.y + b.h / 2);
                            if (bricksRemaining <= 0) { levelMightBeComplete = true; }
                        } else { b.color = BRICK_HEALTH_COLORS[b.health] || BRICK_DEFAULT_COLOR; }
                        updateUI();
                        return; // Ett treff per ball per kloss per frame
                    } } } });

        // Kollisjon med powerups (uendret)
        powerups.forEach((powerup, index) => { /* ... */ });

        // Kall levelComplete *etter* sjekk av alle kollisjoner
        if (levelMightBeComplete && gameRunning) { // Sjekk gameRunning her også
             console.log("CollisionDetection: Flag set, attempting level complete...");
             levelComplete(); // levelComplete vil nå stoppe loopen etc.
        }
    }

    // --- Resten av funksjonene ---
    function createPowerup(x, y) { /* ... (samme som før) ... */ }
    function activatePowerup(type) { /* ... (samme som før, bruk CANVAS_WIDTH) ... */ }
    function createParticles(x, y, color) { /* ... (samme som før) ... */ }
    function updateParticles() { /* ... (samme som før) ... */ }

    // --- Tegnefunksjoner (Med try/catch og logging) ---
    function drawBackground() {
        // console.log("--- Executing drawBackground ---"); // DEBUG (kan fjernes hvis det virker)
        try {
            const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
            gradient.addColorStop(0, BACKGROUND_GRADIENT[0]);
            gradient.addColorStop(0.5, BACKGROUND_GRADIENT[1]);
            gradient.addColorStop(1, BACKGROUND_GRADIENT[2]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        } catch (e) { console.error("Error in drawBackground:", e); gameRunning = false; }
    }

    function drawPaddle() {
        // console.log("--- Executing drawPaddle ---"); // DEBUG
         try {
            ctx.beginPath();
            const gradient = ctx.createLinearGradient(paddleX, CANVAS_HEIGHT - PADDLE_HEIGHT, paddleX, CANVAS_HEIGHT);
            gradient.addColorStop(0, PADDLE_COLOR.accent);
            gradient.addColorStop(1, PADDLE_COLOR.main);
            ctx.fillStyle = gradient;
            const r = 5;
            // ... (resten av path-tegningen for paddle) ...
             ctx.moveTo(paddleX + r, CANVAS_HEIGHT - PADDLE_HEIGHT); ctx.lineTo(paddleX + paddleWidth - r, CANVAS_HEIGHT - PADDLE_HEIGHT); ctx.quadraticCurveTo(paddleX + paddleWidth, CANVAS_HEIGHT - PADDLE_HEIGHT, paddleX + paddleWidth, CANVAS_HEIGHT - PADDLE_HEIGHT + r); ctx.lineTo(paddleX + paddleWidth, CANVAS_HEIGHT - r); ctx.quadraticCurveTo(paddleX + paddleWidth, CANVAS_HEIGHT, paddleX + paddleWidth - r, CANVAS_HEIGHT); ctx.lineTo(paddleX + r, CANVAS_HEIGHT); ctx.quadraticCurveTo(paddleX, CANVAS_HEIGHT, paddleX, CANVAS_HEIGHT - r); ctx.lineTo(paddleX, CANVAS_HEIGHT - PADDLE_HEIGHT + r); ctx.quadraticCurveTo(paddleX, CANVAS_HEIGHT - PADDLE_HEIGHT, paddleX + r, CANVAS_HEIGHT - PADDLE_HEIGHT);
            ctx.fill();
            ctx.closePath();
         } catch (e) { console.error("Error in drawPaddle:", e); gameRunning = false; }
    }

    function drawBalls() {
        // console.log("--- Executing drawBalls ---"); // DEBUG
         try {
            balls.forEach(ball => {
                ctx.beginPath();
                const gradient = ctx.createRadialGradient(ball.x - ball.radius*0.3, ball.y - ball.radius*0.3, ball.radius*0.1, ball.x, ball.y, ball.radius);
                gradient.addColorStop(0, BALL_COLOR.accent);
                gradient.addColorStop(1, BALL_COLOR.main);
                ctx.fillStyle = gradient;
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.closePath();
            });
         } catch (e) { console.error("Error in drawBalls:", e); gameRunning = false; }
    }

     function drawBricks() {
        // console.log("--- Executing drawBricks ---"); // DEBUG
         try {
             bricks.forEach(b => {
                 if (b.status === 1) {
                     ctx.beginPath();
                     ctx.rect(b.x, b.y, b.w, b.h);
                     const color = b.color;
                     const grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
                     grad.addColorStop(0, lightenColor(color, 20));
                     grad.addColorStop(1, darkenColor(color, 20));
                     ctx.fillStyle = grad;
                     ctx.fill();
                     ctx.strokeStyle = darkenColor(color, 40);
                     ctx.lineWidth = 1;
                     ctx.stroke();
                     ctx.closePath();
                 }
             });
         } catch (e) { console.error("Error in drawBricks:", e); gameRunning = false; }
     }

    function drawParticles() { /* ... (med try/catch) ... */ }
    function drawPowerups() { /* ... (med try/catch) ... */ }
    // Hjelpefunksjoner for farge (uendret)
    function lightenColor(hex, percent) { /* ... */ } function darkenColor(hex, percent) { /* ... */ }
    function movePaddle() { /* ... (samme som før, bruk CANVAS_WIDTH) ... */ }
    function moveBalls() { /* ... (samme som før, bruk CANVAS_WIDTH/HEIGHT) ... */ }
    function movePowerups() { /* ... (samme som før, sjekk CANVAS_HEIGHT) ... */ }
    function updateUI() { /* ... (samme som før) ... */ }


    // --- Game State Functions (GameOver, LevelComplete, Victory med loop-stopp) ---
    function levelComplete() {
        if (gamePaused || !gameRunning) return;
        console.log(`>>> LEVEL ${currentLevel} COMPLETE <<<`);
        gamePaused = true; gameRunning = false; // Pause/Stop state

        if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; console.log("Anim frame cancelled for level transition."); }
        else { console.warn("levelComplete: animationFrameId was already null?"); }

        balls.forEach(ball => { ball.dx = 0; ball.dy = 0; });

        // Tegn melding (statisk)
        ctx.fillStyle = 'rgba(0, 80, 0, 0.7)'; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.font = "40px Arial"; ctx.fillStyle = "lime"; ctx.textAlign = "center";
        ctx.fillText(`Nivå ${currentLevel} fullført!`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 20);
        ctx.font = "20px Arial"; ctx.fillStyle = "white";
        ctx.fillText(`Poeng: ${score}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 20);
        ctx.fillText("Gjør klar for neste nivå...", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);

        setTimeout(() => {
            currentLevel++;
            if (currentLevel - 1 >= LEVELS.length) {
                victory();
            } else {
                console.log("Timeout done. Init level:", currentLevel);
                initializeLevel(currentLevel); // Setup next level
                gamePaused = false; gameRunning = true; // Unpause/Run state
                console.log("Restarting game loop.");
                if (!animationFrameId) { gameLoop(); } // START loop again
                else { console.error("CANNOT RESTART LOOP: ID not null!"); cancelAnimationFrame(animationFrameId); animationFrameId = null; gameLoop(); }
            }
        }, 2500);
    }

    function gameOver() {
        console.log(">>> GAME OVER <<<");
        gameRunning = false; // Stop state
        try { backgroundMusic.pause(); backgroundMusic.currentTime = 0; } catch(e) {}

        // Tegn melding (statisk)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.font = "50px Arial"; ctx.fillStyle = "red"; ctx.textAlign = "center";
        ctx.fillText("GAME OVER", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 40);
        ctx.font = "24px Arial"; ctx.fillStyle = "white";
        ctx.fillText(`Poeng: ${score} | Nivå: ${currentLevel}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 10);
        ctx.fillText("Trykk F5 for å prøve igjen", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);
        ctx.font = "14px Arial"; ctx.fillStyle = "grey";
        ctx.fillText(`Versjon ${VERSION}`, CANVAS_WIDTH - 60, CANVAS_HEIGHT - 15);

        if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; console.log("Game loop stopped by gameOver."); }
    }

    function victory() {
         console.log(">>> VICTORY <<<");
         gameRunning = false; // Stop state
         try { backgroundMusic.pause(); backgroundMusic.currentTime = 0; } catch(e) {}

         // Tegn melding (statisk)
         ctx.fillStyle = 'rgba(0, 100, 200, 0.8)'; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
         ctx.font = "50px Arial"; ctx.fillStyle = "#FFD700"; ctx.textAlign = "center";
         ctx.fillText("GRATULERER!", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 40);
         ctx.font = "28px Arial"; ctx.fillStyle = "white";
         ctx.fillText("Du klarte alle nivåene!", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 10);
         ctx.fillText(`Sluttpoeng: ${score}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);
         ctx.font = "20px Arial";
         ctx.fillText("Trykk F5 for å spille igjen", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 90);
         ctx.font = "14px Arial"; ctx.fillStyle = "lightgrey";
         ctx.fillText(`Versjon ${VERSION}`, CANVAS_WIDTH - 60, CANVAS_HEIGHT - 15);

         if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; console.log("Game loop stopped by victory."); }
     }


    // --- Hoved Spill-Loop (Revidert for robusthet) ---
    function gameLoop() {
        // 1. Stopp hvis gameRunning er false
        if (!gameRunning) {
            console.log("Loop Check: gameRunning is false. Terminating loop.");
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            return;
        }

        // 2. Kjør Updates
        try {
            movePaddle();
            moveBalls();
            movePowerups();
            updateParticles();
            collisionDetection(); // Kan sette gameRunning = false via gameOver/levelComplete/victory
        } catch (error) {
            console.error("Error during updates:", error);
            gameRunning = false; // Stopp på feil
        }

        // 3. Sjekk *igjen* før tegning (viktig!)
        if (!gameRunning) {
            console.log("Loop Check: gameRunning became false after updates. Skipping draw. Loop will terminate.");
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } // Stopp neste frame
            return;
        }

        // 4. Tegn Alt (kun hvis vi fortsatt kjører)
        try {
             // console.log("Loop: Drawing elements..."); // DEBUG (fjern når det virker)
             // console.log(" > ctx valid?", !!(ctx && ctx.fillRect)); // DEBUG
            drawBackground();
            drawBricks();
            drawParticles();
            drawPowerups();
            drawPaddle();
            drawBalls();
        } catch(error) {
            console.error("Error during drawing:", error);
            gameRunning = false; // Stopp på feil
        }

        // 5. Be om neste Frame (kun hvis vi skal fortsette)
        if (gameRunning) {
            animationFrameId = requestAnimationFrame(gameLoop);
        } else {
            // Vi stoppet (enten pga feil eller normal slutt), sikre at ID er null
             console.log("Loop Check: gameRunning is false after drawing phase. Loop terminates now.");
             if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
         }
    }

    // --- Initial Setup ---
    console.log(`BBreakout ${VERSION} Script loaded. Waiting for start button click.`);
    // Kjør lydoppsett FØR spillstart for å sette initielt volum
    setupAudioControls();

</script>

</body>
</html>
