<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>BBreakout v1.4 - Enhanced HTML Arkanoid</title> <style>
    body {
        background: #222;
        margin: 0;
        padding: 20px 0; /* Legg til litt padding øverst */
        display: flex;
        justify-content: center;
        /* align-items: center; Fjernet denne for å unngå vertikal sentrering */
        min-height: 100vh; /* Sørg for at body fyller høyden */
        font-family: Arial, sans-serif;
        color: #fff;
        overflow: hidden;
    }
    #gameContainer {
        position: relative;
        /* Økt størrelse */
        width: 800px;
        /* Height satt av canvas + ui */
        display: flex;
        flex-direction: column;
        align-items: center;
        /* margin-top: 20px; Alternativ til padding på body */
    }
    canvas {
        display: block;
        border: 1px solid #555;
         /* Størrelse satt i HTML-attributter */
    }
    .hidden {
        display: none !important;
    }
    #startScreen {
        position: absolute;
        top: 0;
        left: 0;
        /* Økt størrelse */
        width: 800px;
        height: 600px;
        background-color: #1a1a1a;
        background-image: url('image/BBreakout.png'); /* HUSK RIKTIG STI */
        background-size: cover;
        background-position: center;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10;
        border: 1px solid #555;
        box-sizing: border-box;
    }
     #startScreenContent {
        display: flex;
        flex-direction: column;
        align-items: center;
        /* Justert margin for større skjerm */
        margin-top: 300px;
        background: rgba(0,0,0,0.5);
        padding: 20px;
        border-radius: 10px;
    }
    #startButton {
        padding: 15px 30px;
        font-size: 24px;
        cursor: pointer;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        box-shadow: 0 4px #999;
        transition: background-color 0.2s, box-shadow 0.2s, transform 0.2s;
    }
    #startButton:hover { background-color: #45a049; }
     #startButton:active { background-color: #3e8e41; box-shadow: 0 2px #666; transform: translateY(2px); }
    #versionText {
        position: absolute;
        bottom: 15px; /* Litt mer luft */
        right: 15px;
        font-size: 14px; /* Litt større */
        color: rgba(255, 255, 255, 0.7);
    }

    #uiContainer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%; /* Dekker bredden til container */
        padding: 8px 15px; /* Litt mer padding */
        background: rgba(0,0,0,0.6);
        box-sizing: border-box;
        border-bottom-left-radius: 5px;
        border-bottom-right-radius: 5px;
        margin-top: -1px;
        height: 50px;
    }
    #gameInfo { display: flex; gap: 20px; } /* Økt gap */
     #audioControls { display: flex; align-items: center; gap: 10px; }
     #audioControls label { font-size: 14px; margin-right: -5px; }
    #volumeSlider { width: 100px; cursor: pointer; accent-color: #0095DD; } /* Bredere slider */
    #muteButton { padding: 5px 10px; font-size: 12px; cursor: pointer; background-color: #0077AA; color: white; border: none; border-radius: 3px; min-width: 60px; text-align: center; }
     #muteButton:hover { background-color: #005588; }
</style>
</head>
<body>

<div id="gameContainer">
    <div id="startScreen">
         <div id="startScreenContent">
            <button id="startButton">Start Spillet</button>
         </div>
        <div id="versionText">Versjon 1.4</div> </div>

    <canvas id="gameCanvas" width="800" height="600" class="hidden"></canvas>

    <div id="uiContainer" class="hidden">
        <div id="gameInfo">
            <span id="score">Poeng: 0</span>
            <span id="lives">Liv: 3</span>
            <span id="level">Nivå: 1</span>
        </div>
        <div id="audioControls">
             <label for="volumeSlider">Volum:</label>
            <input type="range" id="volumeSlider" min="0" max="100" value="20">
            <button id="muteButton">Mute</button>
        </div>
    </div>
</div>

<audio id="backgroundMusic" loop preload="auto"> <source src="audio/BBreakout.mp3" type="audio/mpeg"> Nettleseren din støtter ikke audio-elementet. </audio>
<audio id="hitSound" preload="auto"> <source src="audio/hit.wav" type="audio/wav"> Nettleseren din støtter ikke audio-elementet. </audio>
<audio id="paddleSound" preload="auto"> <source src="audio/paddle.wav" type="audio/wav"> Nettleseren din støtter ikke audio-elementet. </audio>


<script>
    // --- DOM Element References ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const livesElement = document.getElementById('lives');
    const levelElement = document.getElementById('level');
    const startScreen = document.getElementById('startScreen');
    const startButton = document.getElementById('startButton');
    const uiContainer = document.getElementById('uiContainer');
    const volumeSlider = document.getElementById('volumeSlider');
    const muteButton = document.getElementById('muteButton');
    const versionText = document.getElementById('versionText');

    // Audio Elements
    const backgroundMusic = document.getElementById('backgroundMusic');
    const hitSound = document.getElementById('hitSound');
    const paddleSound = document.getElementById('paddleSound');
    const allSounds = [backgroundMusic, hitSound, paddleSound];

    // --- Spillkonstanter og Variabler ---
    const VERSION = "1.4"; // *** VERSJONSNUMMER ***
    const CANVAS_WIDTH = canvas.width;   // Bruk faktiske canvas-dimensjoner
    const CANVAS_HEIGHT = canvas.height;
    const PADDLE_HEIGHT = 15;
    const PADDLE_BASE_WIDTH = 120; // Litt bredere paddle for større skjerm
    const PADDLE_SPEED = 10;       // Litt raskere paddle
    const BALL_RADIUS = 10;        // Litt større ball
    const INITIAL_BALL_SPEED = 4.5;  // Økt basehastighet for større skjerm
    // Brick dimensions (holdt relativt like, men juster antall/offset)
    const BRICK_WIDTH = 65;
    const BRICK_HEIGHT = 20;
    const BRICK_PADDING = 8;
    const BRICK_OFFSET_TOP = 50;   // Mer plass øverst
    // BRICK_OFFSET_LEFT beregnes dynamisk i initializeBricks
    const PARTICLE_LIFESPAN = 30;
    const POWERUP_CHANCE = 0.15;
    const POWERUP_SPEED = 2.0; // Litt raskere powerups
    const POWERUP_SIZE = 18; // Litt større powerups
    const INITIAL_VOLUME = 0.2;

    // Farger (uendret)
    const BRICK_HEALTH_COLORS = { 4: "#FF1493", 3: "#8333FF", 2: "#FF8D33", 1: "#FFC300", };
    const BRICK_DEFAULT_COLOR = "#DAF7A6";
    const PADDLE_COLOR = { main: '#0095DD', accent: '#00CFFF' };
    const BALL_COLOR = { main: '#FFFFFF', accent: '#DDDDDD' };
    const BACKGROUND_GRADIENT = ['#111', '#333', '#111'];
    const PARTICLE_COLORS = ["#FFA07A", "#FF7F50", "#FF6347", "#FF4500"];
    const POWERUP_COLORS = { 'LARGER_PADDLE': '#33FF57', 'MULTI_BALL': '#FFC300', 'SLOW_BALL': '#33D4FF', 'EXTRA_LIFE': '#FF5733' };

    // Nivådata (justert for potensielt flere kolonner)
    const LEVELS = [
        // Nivå 1 (10 kolonner)
        [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
            [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
        ],
        // Nivå 2 (10 kolonner)
        [
            [2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [0, 1, 2, 2, 2, 2, 2, 2, 1, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
        ],
         // Nivå 3 (10 kolonner)
        [
            [1, 2, 3, 3, 3, 3, 3, 3, 2, 1],
            [1, 2, 0, 0, 0, 0, 0, 0, 2, 1],
            [1, 2, 0, 2, 2, 2, 2, 0, 2, 1],
            [0, 1, 2, 1, 1, 1, 1, 2, 1, 0],
            [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
        ],
        // Nivå 4 (10 kolonner) - Tøffere
        [
            [3, 3, 3, 3, 3, 3, 3, 3, 3, 3],
            [2, 2, 2, 2, 2, 2, 2, 2, 2, 2],
            [3, 0, 3, 0, 3, 0, 3, 0, 3, 0],
            [2, 0, 2, 0, 2, 0, 2, 0, 2, 0],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ],
    ];


    // Spillstatus
    let paddleWidth = PADDLE_BASE_WIDTH;
    let paddleX = (CANVAS_WIDTH - paddleWidth) / 2; // Bruk konstant
    let paddleLastX = paddleX;
    let paddleVelX = 0;
    let rightPressed = false;
    let leftPressed = false;
    let balls = [];
    let bricks = [];
    let particles = [];
    let powerups = [];
    let score = 0;
    let lives = 3;
    let currentLevel = 1;
    let gameRunning = false;
    let gamePaused = false; // Viktig for overganger
    let bricksRemaining = 0;
    let activePowerups = { largerPaddle: null, slowBall: null };
    let animationFrameId = null;
    let isMuted = false;
    let lastVolume = INITIAL_VOLUME;

    const PowerupType = { LARGER_PADDLE: 'LARGER_PADDLE', MULTI_BALL: 'MULTI_BALL', SLOW_BALL: 'SLOW_BALL', EXTRA_LIFE: 'EXTRA_LIFE' };

    // --- Lydkontroll (uendret, men sjekk funksjonalitet) ---
    function playSound(soundElement) { /* ... (samme som før) ... */ }
    function setGlobalVolume(volume) { /* ... (samme som før) ... */ }
    function toggleMute() { /* ... (samme som før) ... */ }
    function setupAudioControls() { /* ... (samme som før) ... */ }


    // --- Start Spillet Funksjon ---
    function startGame() {
        console.log("Attempting to start game...");
        startScreen.classList.add('hidden');
        canvas.classList.remove('hidden');
        uiContainer.classList.remove('hidden');

        setupAudioControls();
        playSound(backgroundMusic);

        score = 0; lives = 3; currentLevel = 1;
        gameRunning = true;   // Sett før initializeLevel
        gamePaused = false;  // Sikre at vi ikke er pauset
        initializeLevel(currentLevel);

        // Start game loop hvis den ikke kjører
        if (!animationFrameId) {
             console.log("Starting game loop for the first time.");
             gameLoop();
        } else {
             console.warn("Game loop already running? animationFrameId:", animationFrameId);
        }
    }
    startButton.addEventListener('click', startGame);
    versionText.textContent = `Versjon ${VERSION}`;


    // --- Initialisering ---
    function initializeLevel(level) {
        console.log("--- Initializing level:", level, "---");
        // gamePaused = true; // Pause mens vi setter opp? KAN skape problemer. La oss prøve uten.
        paddleWidth = PADDLE_BASE_WIDTH;
        paddleX = (CANVAS_WIDTH - paddleWidth) / 2;
        paddleLastX = paddleX; paddleVelX = 0;
        balls = [];

        const initialAngle = (Math.random() * 60 + 60) * (Math.PI / 180);
        createBall(
            CANVAS_WIDTH / 2,
            CANVAS_HEIGHT - PADDLE_HEIGHT - BALL_RADIUS - 50, // Litt høyere start for større skjerm
            Math.cos(initialAngle) * INITIAL_BALL_SPEED,
           -Math.sin(initialAngle) * INITIAL_BALL_SPEED
        );

        initializeBricks(); // Laster klosser for nivået
        powerups = []; particles = [];
        if (activePowerups.largerPaddle) clearTimeout(activePowerups.largerPaddle);
        if (activePowerups.slowBall) clearTimeout(activePowerups.slowBall);
        activePowerups = { largerPaddle: null, slowBall: null };

        updateUI();
        // gamePaused = false; // Fjernet pausen, så trenger ikke unpause
        console.log("--- Level", level, "initialization complete ---");
    }


    // --- Spillogikk Funksjoner ---
     function createBall(x, y, dx, dy) {
        const speedMultiplier = 1 + (currentLevel - 1) * 0.08; // Justert økning
        const baseSpeed = Math.sqrt(dx*dx + dy*dy) * speedMultiplier;
        balls.push({
            x: x, y: y,
            dx: dx * speedMultiplier,
            dy: dy * speedMultiplier,
            radius: BALL_RADIUS,
            baseSpeed: baseSpeed > 0 ? baseSpeed : INITIAL_BALL_SPEED
        });
     }

     function initializeBricks() {
         bricks = [];
         bricksRemaining = 0;
         const levelIndex = currentLevel - 1;

         if (levelIndex >= LEVELS.length) { victory(); return; }

         const levelData = LEVELS[levelIndex];
         const numRows = levelData.length;
         let numCols = 0;
         if (numRows > 0) { numCols = levelData[0].length; } // Antall kolonner fra nivådata

         // Dynamisk beregning av offset for sentrering
         const totalBrickGridWidth = numCols * BRICK_WIDTH + (numCols - 1) * BRICK_PADDING;
         const calculatedOffsetLeft = (CANVAS_WIDTH - totalBrickGridWidth) / 2;
         console.log(`Level ${currentLevel}: ${numCols} columns, OffsetLeft: ${calculatedOffsetLeft.toFixed(1)}`);


         for (let r = 0; r < numRows; r++) {
             // Sikre at raden har forventet lengde (valgfritt, men tryggere)
             if (levelData[r].length !== numCols) {
                 console.warn(`Level ${currentLevel}, row ${r} has inconsistent length.`);
                 continue; // Hopp over denne raden hvis lengden er feil
             }
             for (let c = 0; c < numCols; c++) {
                 const brickHealth = levelData[r][c];
                 if (brickHealth > 0) {
                     const brickX = (c * (BRICK_WIDTH + BRICK_PADDING)) + calculatedOffsetLeft;
                     const brickY = (r * (BRICK_HEIGHT + BRICK_PADDING)) + BRICK_OFFSET_TOP;
                     bricks.push({
                         x: brickX, y: brickY,
                         w: BRICK_WIDTH, h: BRICK_HEIGHT,
                         status: 1, initialHealth: brickHealth, health: brickHealth,
                         color: BRICK_HEALTH_COLORS[brickHealth] || BRICK_DEFAULT_COLOR
                     });
                     bricksRemaining++;
                 }
             }
         }
         console.log("Bricks initialized. Count:", bricksRemaining);
     }

    // --- Input Handlers (uendret) ---
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);
    document.addEventListener("mousemove", mouseMoveHandler, false);
    function keyDownHandler(e) { if(e.key == "Right" || e.key == "ArrowRight") rightPressed = true; else if(e.key == "Left" || e.key == "ArrowLeft") leftPressed = true; }
    function keyUpHandler(e) { if(e.key == "Right" || e.key == "ArrowRight") rightPressed = false; else if(e.key == "Left" || e.key == "ArrowLeft") leftPressed = false; }
    function mouseMoveHandler(e) { const rect = canvas.getBoundingClientRect(); const root = document.documentElement; let relativeX = e.clientX - rect.left - root.scrollLeft; if (relativeX > paddleWidth / 2 && relativeX < CANVAS_WIDTH - paddleWidth / 2) { paddleX = relativeX - paddleWidth / 2; } else if (relativeX <= paddleWidth / 2) { paddleX = 0; } else { paddleX = CANVAS_WIDTH - paddleWidth; } }

    // --- Collision Detection (Liten justering for å unngå dobbel levelComplete) ---
    function collisionDetection() {
        if (gamePaused) return; // Ikke sjekk kollisjoner hvis pauset

        let levelMightBeComplete = false; // Flag for å sjekke etter alle kollisjoner

        balls.forEach((ball, ballIndex) => {
            // Kollisjon med klosser
            for (let i = bricks.length - 1; i >= 0; i--) {
                let b = bricks[i];
                if (b.status == 1) {
                    if (ball.x + ball.radius > b.x && ball.x - ball.radius < b.x + b.w &&
                        ball.y + ball.radius > b.y && ball.y - ball.radius < b.y + b.h)
                    {
                        playSound(hitSound);
                        const overlapX = (ball.radius + b.w / 2) - Math.abs(ball.x - (b.x + b.w / 2));
                        const overlapY = (ball.radius + b.h / 2) - Math.abs(ball.y - (b.y + b.h / 2));

                        if (overlapX < overlapY) { ball.dx = -ball.dx; ball.x += (ball.x > b.x + b.w / 2 ? overlapX : -overlapX); }
                        else { ball.dy = -ball.dy; ball.y += (ball.y > b.y + b.h / 2 ? overlapY : -overlapY); }

                        b.health--;
                        score += 5;

                        if (b.health <= 0) {
                            b.status = 0;
                            score += 15 * b.initialHealth;
                            bricksRemaining--;
                            createParticles(ball.x, ball.y, b.color);
                            if (Math.random() < POWERUP_CHANCE) createPowerup(b.x + b.w / 2, b.y + b.h / 2);

                             // Sjekk om *dette* var den siste klossen
                             if (bricksRemaining <= 0) {
                                 console.log("Last brick hit! Flagging for level complete check.");
                                 levelMightBeComplete = true; // Sett flagg, ikke kall levelComplete direkte
                             }

                        } else {
                            b.color = BRICK_HEALTH_COLORS[b.health] || BRICK_DEFAULT_COLOR;
                        }
                        updateUI();
                        return; // Ett treff per ball per kloss per frame
                    }
                }
            }
        });

        // Kollisjon med powerups (uendret)
        powerups.forEach((powerup, index) => { /* ... (samme som før) ... */ });

        // Kall levelComplete *etter* at alle ball/kloss-kollisjoner er sjekket, hvis flagget er satt
        if (levelMightBeComplete && gameRunning && !gamePaused) {
             console.log("Checking level complete flag...");
             levelComplete();
        }
    }


    // --- Resten av funksjonene (createPowerup, particles, drawing etc.) ---
    // Stort sett uendret, men bruker CANVAS_WIDTH/HEIGHT der det passer
    function createPowerup(x, y) { /* ... (samme som før) ... */ }
    function activatePowerup(type) { /* ... (samme som før, men bruk CANVAS_WIDTH) ... */ }
    function createParticles(x, y, color) { /* ... (samme som før) ... */ }
    function updateParticles() { /* ... (samme som før) ... */ }
    function drawBackground() { /* ... (samme som før, bruker canvas.height) ... */ }
    function drawBalls() { /* ... (samme som før) ... */ }
    function drawPaddle() { /* ... (samme som før, bruk CANVAS_HEIGHT) ... */ }
    function drawBricks() { /* ... (samme som før) ... */ }
    function drawParticles() { /* ... (samme som før) ... */ }
    function drawPowerups() { /* ... (samme som før) ... */ }
    function lightenColor(hex, percent) { /* ... (samme som før) ... */ }
    function darkenColor(hex, percent) { /* ... (samme som før) ... */ }
    function movePaddle() { /* ... (samme som før, bruk CANVAS_WIDTH) ... */ }

    function moveBalls() {
        if (gamePaused) return; // Ikke flytt baller hvis pauset

        balls.forEach((ball, index) => {
            // Vegg X
            if(ball.x + ball.dx > CANVAS_WIDTH - ball.radius || ball.x + ball.dx < ball.radius) { ball.dx = -ball.dx; createParticles(ball.x, ball.y, '#aaa'); }
            // Vegg Y (Topp)
            if(ball.y + ball.dy < ball.radius) { ball.dy = -ball.dy; createParticles(ball.x, ball.y, '#aaa'); }
            // Paddle / Bunn
            else if(ball.y + ball.radius >= CANVAS_HEIGHT - PADDLE_HEIGHT && ball.y - ball.radius < CANVAS_HEIGHT ) {
                 if(ball.x + ball.radius > paddleX && ball.x - ball.radius < paddleX + paddleWidth && ball.dy > 0) {
                    playSound(paddleSound);
                    ball.dy = -ball.dy;
                    ball.y = CANVAS_HEIGHT - PADDLE_HEIGHT - ball.radius - 0.1;

                    let hitPos = (ball.x - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
                    hitPos = Math.max(-1, Math.min(1, hitPos));
                    const angleFactor = 2.5; // Litt mer vinkelpåvirkning
                    ball.dx = ball.dx * 0.5 + hitPos * angleFactor * ball.baseSpeed * 0.6;

                    const spinFactor = 0.2;
                    ball.dx += paddleVelX * spinFactor;

                    const currentSpeed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                    const targetSpeed = ball.baseSpeed;
                    const maxSpeed = ball.baseSpeed * 1.5; // Maks hastighet

                    if (currentSpeed > maxSpeed) { const scale = maxSpeed / currentSpeed; ball.dx *= scale; ball.dy *= scale; }
                    else if (currentSpeed < targetSpeed * 0.8 && currentSpeed > 0.1) { const scale = (targetSpeed * 0.8) / currentSpeed; ball.dx *= scale; ball.dy *= scale; }

                    createParticles(ball.x, ball.y+ball.radius, PADDLE_COLOR.main);
                } else if (ball.y + ball.radius >= CANVAS_HEIGHT) { // Bunn
                     balls.splice(index, 1);
                     if (balls.length === 0) {
                         lives--; updateUI();
                         if(lives <= 0) { gameOver(); }
                         else {
                             paddleX = (CANVAS_WIDTH - PADDLE_BASE_WIDTH) / 2;
                             paddleWidth = PADDLE_BASE_WIDTH;
                             const initialAngle = (Math.random() * 60 + 60) * (Math.PI / 180);
                             createBall( CANVAS_WIDTH / 2, CANVAS_HEIGHT - PADDLE_HEIGHT - BALL_RADIUS - 50, Math.cos(initialAngle) * INITIAL_BALL_SPEED, -Math.sin(initialAngle) * INITIAL_BALL_SPEED );
                         } } } }
            ball.x += ball.dx; ball.y += ball.dy;
        });
    }

    function movePowerups() { if (gamePaused) return; /* ... (samme som før, men sjekk CANVAS_HEIGHT) ... */ }
    function updateUI() { scoreElement.textContent = "Poeng: " + score; livesElement.textContent = "Liv: " + lives; levelElement.textContent = "Nivå: " + currentLevel; }

    // --- Game State Functions (GameOver, LevelComplete, Victory) ---
    function gameOver() {
        console.log(">>> GAME OVER <<<");
        gameRunning = false; // Stopp hovedlogikk
        // Ikke sett gamePaused = true her, la gameLoop stoppe naturlig
        try { backgroundMusic.pause(); backgroundMusic.currentTime = 0; } catch(e) { /* ... */ }

        // Tegn game over-skjerm (trenger ikke timeout hvis loopen stopper)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.font = "50px Arial"; ctx.fillStyle = "red"; ctx.textAlign = "center"; // Større font
        ctx.fillText("GAME OVER", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 40);
        ctx.font = "24px Arial"; ctx.fillStyle = "white"; // Større font
        ctx.fillText(`Poeng: ${score} | Nivå: ${currentLevel}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 10);
        ctx.fillText("Trykk F5 for å prøve igjen", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);
        ctx.font = "14px Arial"; ctx.fillStyle = "grey";
        ctx.fillText(`Versjon ${VERSION}`, CANVAS_WIDTH - 60, CANVAS_HEIGHT - 15);

         // Stopp loopen eksplisitt etter å ha tegnet
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            console.log("Game loop stopped by gameOver.");
        }
    }

    // *** REVIDERT levelComplete for å fikse frys ***
    function levelComplete() {
        if (gamePaused) return; // Forhindre dobbel kjøring

        console.log(`>>> LEVEL ${currentLevel} COMPLETE <<<`);
        gamePaused = true; // Sett pause MENS vi viser melding og venter
        balls.forEach(ball => { ball.dx = 0; ball.dy = 0; });

        // Tegn nivå fullført-melding umiddelbart
        ctx.fillStyle = 'rgba(0, 80, 0, 0.7)'; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.font = "40px Arial"; ctx.fillStyle = "lime"; ctx.textAlign = "center";
        ctx.fillText(`Nivå ${currentLevel} fullført!`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 20);
        ctx.font = "20px Arial"; ctx.fillStyle = "white";
        ctx.fillText(`Poeng: ${score}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 20);
        ctx.fillText("Gjør klar for neste nivå...", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);

        // Vent før neste nivå starter
        setTimeout(() => {
            currentLevel++;
             if (currentLevel - 1 >= LEVELS.length) {
                 victory(); // Siste nivå -> Seier
             } else {
                console.log("Preparing to initialize next level:", currentLevel);
                initializeLevel(currentLevel); // Sett opp neste nivå
                console.log("Initialization complete. Unpausing game.");
                gamePaused = false; // FJERN PAUSE ETTER initialisering

                // VIKTIG: Sørg for at gameLoop kjører igjen hvis den stoppet pga pausen
                if (gameRunning && !animationFrameId) {
                    console.log("Game loop was stopped, restarting...");
                    gameLoop();
                } else {
                     console.log("Game loop should resume automatically.");
                     // Trenger ikke kalle gameLoop() her hvis den bare var pauset.
                     // Den vil fortsette på neste requestAnimationFrame.
                 }
            }
        }, 2500); // Ventetid
    }

     function victory() {
         console.log(">>> VICTORY <<<");
         gameRunning = false;
         // Tegn seiersskjerm
         ctx.fillStyle = 'rgba(0, 100, 200, 0.8)'; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
         ctx.font = "50px Arial"; ctx.fillStyle = "#FFD700"; ctx.textAlign = "center"; // Større
         ctx.fillText("GRATULERER!", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 40);
         ctx.font = "28px Arial"; ctx.fillStyle = "white"; // Større
         ctx.fillText("Du klarte alle nivåene!", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 10);
         ctx.fillText(`Sluttpoeng: ${score}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);
         ctx.font = "20px Arial"; // Større
         ctx.fillText("Trykk F5 for å spille igjen", CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 90);
         ctx.font = "14px Arial"; ctx.fillStyle = "lightgrey";
         ctx.fillText(`Versjon ${VERSION}`, CANVAS_WIDTH - 60, CANVAS_HEIGHT - 15);

          // Stopp loopen eksplisitt
         if (animationFrameId) {
             cancelAnimationFrame(animationFrameId);
             animationFrameId = null;
             console.log("Game loop stopped by victory.");
         }
     }


    // --- Hoved Spill-Loop (Revidert for pause-håndtering) ---
    function gameLoop() {
         // 1. Skal loopen kjøre i det hele tatt?
         if (!gameRunning) {
             console.log("Game not running. Stopping loop.");
             if (animationFrameId) {
                 cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
             }
             return; // Stopp helt
         }

         // 2. Er spillet midlertidig pauset (f.eks. nivåovergang)?
         if (gamePaused) {
             console.log("Game loop paused..."); // Logg at vi er pauset
             // VIKTIG: Be om neste frame selv om vi er pauset,
             // slik at vi kan tegne pause-skjermen og loopen kan gjenopptas.
             animationFrameId = requestAnimationFrame(gameLoop);
             return; // Hopp over resten av logikken denne framen
         }

         // 3. Kjør normal spill-logikk og tegning
         // Oppdatering
         movePaddle();
         moveBalls();
         movePowerups();
         updateParticles();
         collisionDetection(); // Kan sette gamePaused hvis level complete

         // Tegning (kun hvis vi fortsatt kjører og ikke ble pauset av collisionDetection)
         if (gameRunning && !gamePaused) {
             drawBackground();
             drawBricks();
             drawParticles();
             drawPowerups();
             drawPaddle();
             drawBalls();
         }

         // 4. Be om neste frame (kun hvis vi fortsatt skal kjøre)
         if (gameRunning) {
             animationFrameId = requestAnimationFrame(gameLoop);
         } else if (animationFrameId) {
              // Hvis gameRunning ble satt til false (game over/victory),
              // kanseller siste forespørsel hvis den ikke ble gjort i gameOver/victory
              cancelAnimationFrame(animationFrameId);
              animationFrameId = null;
              console.log("Game loop stopping due to gameRunning=false.");
         }
    }

    // --- Initial Setup ---
    console.log("Script loaded. Waiting for start button click.");
    setupAudioControls();

</script>

</body>
</html>
